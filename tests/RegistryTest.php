<?php

declare(strict_types=1);

namespace IfCastle\Exceptions;

use IfCastle\Exceptions\Errors\Error;

/**
 * Simulating PHP's register_shutdown_function.
 *
 * @param       callback      $handler
 */
function register_shutdown_function($handler): void
{
    $GLOBALS['shutdown_function'] = $handler;
}

/**
 * error_get_last simulation.
 *
 * @return array
 */
function error_get_last()
{
    return $GLOBALS['Last_error'];
}

class ExceptionHandler implements \IfCastle\Exceptions\HandlerInterface
{
    /**
     * @var callable
     */
    private $handler;

    public function __construct(callable $handler)
    {
        $this->handler = $handler;
    }

    /**
     * Exception handler.
     *
     *
     */
    #[\Override]
    public function exceptionHandler(\Throwable|\IfCastle\Exceptions\BaseExceptionInterface $exception): void
    {
        \call_user_func($this->handler, $exception);
    }
}

class SaveHandler implements SaveHandlerInterface
{
    /**
     * @var callable
     */
    private $handler;

    public function __construct(callable $handler)
    {
        $this->handler = $handler;
    }

    /**
     * Save handler method.
     *
     *
     */
    #[\Override]
    public function saveExceptions(array $exceptions, callable $resetLog, array $loggerOptions = [], array $debugOptions = []): void
    {
        \call_user_func($this->handler, $exceptions, $resetLog, $loggerOptions, $debugOptions);
    }
}

/**
 * Test class for Registry.
 * Generated by PHPUnit on 2012-02-12 at 19:41:28.
 */
class RegistryTest extends \PHPUnit\Framework\TestCase
{
    /**
     * Test data for exception.
     */
    protected array $testData;

    /**
     * Exception Information.
     */
    protected array $testBaseData;

    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    #[\Override]
    protected function setUp(): void
    {
        Registry::resetExceptionLog();

        $this->testData =
        [
            'level'         => BaseExceptionInterface::CRITICAL,
            'ident'         => 'test_ident',
            'exdata'        => [1,2,'string'],
        ];

        $this->testBaseData =
        [
            'message'   => 'test message',
            'code'      => 11223344,
            'previous'  => new \Exception('previous message', 123),
        ];
    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    #[\Override]
    protected function tearDown(): void
    {
        Registry::restoreGlobalHandlers();
    }

    protected function init_Registry()
    {
        Registry::registerException(
            new \Exception(
                'test code1',
                10
            )
        );
        Registry::registerException(
            new \Exception(
                'test code2',
                11
            )
        );
        Registry::registerException(
            new \Exception(
                'test code3',
                12
            )
        );
    }


    /**
     * Testing the Exception Log.
     */
    public function testRegister_exception(): void
    {
        $exceptions = [];

        new BaseException('test message1', 10);

        $exceptions[] = new LoggableException('test message 2', 10);
        $exceptions[] = new LogicalException('logical message');
        $exceptions[] = new MethodNotCallable('test_method');
        $exceptions[] = new ObjectNotInitialized($this);
        $exceptions[] = new UnexpectedMethodMode(__METHOD__, 'test_mode');
        $exceptions[] = new RecursionLimitExceeded(10);
        $exceptions[] = new RequiredValueEmpty('var', 'var_expected');
        $exceptions[] = new UnexpectedValueType('var', '112233', '11');

        foreach (Registry::getExceptionLog() as $exception) {
            $expected = \array_shift($exceptions);
            $this->assertTrue($exception === $expected);
        }

        $this->assertTrue($exceptions === [], '$exceptions contains unknowns elements');
    }

    /**
     * These exceptions should not be logged.
     */
    public function testRegister_exception_null(): void
    {
        Registry::registerException([]);

        $exceptions = Registry::getExceptionLog();

        $this->assertTrue($exceptions === [], '$exceptions contains unknowns elements');
    }

    /**
     * Testing global handlers.
     */
    public function _testInstall_global_handlers(): void
    {
        Registry::installGlobalHandlers();

        $exceptions                 = Registry::getExceptionLog();

        $this->assertTrue(\count($exceptions) === 1, '$exceptions count must equal 1');

        $this->assertArrayHasKey(0, $exceptions);

        $error = $exceptions[0];

        $this->assertInstanceOf('\Exceptions\BaseExceptionInterface', $error);
        $this->assertInstanceOf('\Exceptions\Errors\Error', $error);

        $this->assertEquals(
            "Use of undefined constant CONSTANT_UNDEFINED - assumed 'CONSTANT_UNDEFINED'",
            $error->getMessage()
        );

        $this->assertIsCallable($GLOBALS['shutdown_function']);

        Registry::restoreGlobalHandlers();
    }

    public function testExceptionHandler(): void
    {
        // Should be registered in constructor
        $exception  = new LoggableException('test');

        // Should be registered as unhandled
        Registry::exceptionHandler(new BaseException('test2'));

        $exceptions = Registry::getExceptionLog();

        $this->assertTrue(\count($exceptions) === 3, '$exceptions count must equal 3');
        $this->assertTrue($exception === $exceptions[0], 'Exception not found in registry');
        $this->assertTrue($exceptions[2] instanceof UnhandledException, 'Last exception not instance of UnhandledException');

        Registry::resetExceptionLog();

        // Это исключение не должно логироваться повторно
        $exception = new LoggableException('test');
        Registry::exceptionHandler($exception);

        $exceptions = Registry::getExceptionLog();

        $this->assertTrue(\count($exceptions) === 2, '$exceptions count must equal 2');
        $this->assertTrue($exception === $exceptions[0], 'Exception not found in registry');
        $this->assertTrue($exceptions[1] instanceof UnhandledException, 'Exception5 not instance of UnhandledException');

        Registry::resetExceptionLog();

        $exception = new \Exception('test');
        Registry::exceptionHandler(new LoggableException($exception));

        $exceptions = Registry::getExceptionLog();

        $this->assertTrue(\count($exceptions) === 2, '$exceptions count must equal 2');
        $this->assertTrue($exception === $exceptions[0], 'Exception not found in registry');
        $this->assertTrue($exceptions[1] instanceof UnhandledException, 'Exception5 not UnhandledException');
    }

    /**
     * error handler.
     */
    public function testErrorHandler(): void
    {
        $errors                     =
        [
            E_ERROR                 => BaseExceptionInterface::ERROR,
            E_WARNING               => BaseExceptionInterface::WARNING,
            E_PARSE                 => BaseExceptionInterface::CRITICAL,
            E_NOTICE                => BaseExceptionInterface::NOTICE,
            E_CORE_ERROR            => BaseExceptionInterface::EMERGENCY,
            E_CORE_WARNING          => BaseExceptionInterface::WARNING,
            E_COMPILE_ERROR         => BaseExceptionInterface::EMERGENCY,
            E_COMPILE_WARNING       => BaseExceptionInterface::WARNING,
            E_USER_ERROR            => BaseExceptionInterface::ERROR,
            E_USER_WARNING          => BaseExceptionInterface::INFO,
            E_USER_NOTICE           => BaseExceptionInterface::DEBUG,
            E_STRICT                => BaseExceptionInterface::ERROR,
            E_RECOVERABLE_ERROR     => BaseExceptionInterface::ERROR,
            E_DEPRECATED            => BaseExceptionInterface::INFO,
            E_USER_DEPRECATED       => BaseExceptionInterface::INFO,
        ];


        Registry::errorHandler(E_ERROR, 'Error', __FILE__, __LINE__);
        Registry::errorHandler(E_WARNING, 'Warning', __FILE__, __LINE__);
        Registry::errorHandler(E_PARSE, 'Error', __FILE__, __LINE__);
        Registry::errorHandler(E_NOTICE, 'Notice', __FILE__, __LINE__);
        Registry::errorHandler(E_CORE_ERROR, 'Error', __FILE__, __LINE__);
        Registry::errorHandler(E_CORE_WARNING, 'Warning', __FILE__, __LINE__);
        Registry::errorHandler(E_COMPILE_ERROR, 'Error', __FILE__, __LINE__);
        Registry::errorHandler(E_COMPILE_WARNING, 'Warning', __FILE__, __LINE__);
        Registry::errorHandler(E_USER_ERROR, 'UserError', __FILE__, __LINE__);
        Registry::errorHandler(E_USER_WARNING, 'UserError', __FILE__, __LINE__);
        Registry::errorHandler(E_USER_NOTICE, 'UserError', __FILE__, __LINE__);
        Registry::errorHandler(E_STRICT, 'Error', __FILE__, __LINE__);
        Registry::errorHandler(E_RECOVERABLE_ERROR, 'Error', __FILE__, __LINE__);
        Registry::errorHandler(E_DEPRECATED, 'Notice', __FILE__, __LINE__);
        Registry::errorHandler(E_USER_DEPRECATED, 'Notice', __FILE__, __LINE__);

        $exceptions = Registry::getExceptionLog();

        $this->assertTrue(\count($exceptions) === \count($errors), '$exceptions count must equal $errors');

        foreach ($exceptions as $error) {
            [$code, $level]     = [\key($errors), \current($errors)];
            \next($errors);

            $this->assertInstanceOf(BaseExceptionInterface::class, $error);
            $this->assertInstanceOf(Error::class, $error);
            $this->assertEquals($code, $error->getCode(), '$error->getCode() failed');
            $this->assertEquals(
                $level,
                $error->getLevel(),
                '$error->get_level() failed (line: ' . $error->getLine() . ')'
            );
            $this->assertInstanceOf(
                'IfCastle\Exceptions\Errors\\' . $error->getMessage(),
                $error,
                'create_error failed for: ' . $error->getMessage() . ':' . $error->getLine()
            );
        }
    }

    public function testFatalErrorHandler(): void
    {
        $GLOBALS['Last_error'] =
        [
            'type'    => E_ERROR,
            'message' => 'error',
            'line'    => 11,
            'file'    => 'file',
        ];

        Registry::fatalErrorHandler();

        $exceptions = Registry::getExceptionLog();

        $this->assertTrue(\count($exceptions) === 1, '$exceptions count must equal 1');

        $this->assertArrayHasKey(0, $exceptions);

        $error = $exceptions[0];

        $this->assertInstanceOf(BaseExceptionInterface::class, $error);
        $this->assertInstanceOf(Error::class, $error);

        $this->assertEquals('error', $error->getMessage(), '$error->getMessage() failed');
        $this->assertEquals(11, $error->getLine(), '$error->getLine() failed');
        $this->assertEquals('file', $error->getFile(), '$error->getFile() failed');
    }

    public function testGetExceptionLog(): void
    {
        $this->init_Registry();

        $i = 0;
        foreach (Registry::getExceptionLog() as $exception) {
            $this->assertEquals('test code' . ($i + 1), $exception->getMessage(), '$exception->getMessage() failed');
            $this->assertEquals(($i + 10), $exception->getCode(), '$exception->getCode() failed');

            $i++;
        }
    }

    public function testUnhandledHandler(): void
    {
        $is_call    = false;

        $exception  = new \Exception('test');

        $callback   = function ($actual_exception) use ($exception, &$is_call) {
            $this->assertTrue($actual_exception === $exception, '$actual_exception is not equal $exception');
            $is_call = true;
        };

        $old         = Registry::setUnhandledHandler(new ExceptionHandler($callback));

        Registry::exceptionHandler($exception);

        // restore
        Registry::setUnhandledHandler($old);

        $this->assertTrue($is_call, '$callback isn\'t called');
    }

    /**
     * @covers \Registry::call_fatal_handler
     * @covers \Registry::set_fatal_handler
     * @covers \BaseException::is_fatal
     * @covers \BaseException::set_fatal
     */
    public function testFatalHandler(): void
    {
        // Case 1: Exception-container

        $is_call    = false;

        $exception  = new \Exception('test');

        $callback   = function ($actual_exception) use ($exception, &$is_call) {
            $this->assertInstanceOf(FatalException::class, $actual_exception);

            /* @var $actual_exception \Exceptions\FatalException */

            $this->assertTrue(
                $actual_exception->getPreviousException() === $exception,
                '$actual_exception not equal $exception'
            );
            $is_call = true;
        };

        Registry::setFatalHandler(new ExceptionHandler($callback));

        new FatalException($exception);

        $this->assertTrue($is_call, '$callback isn\'t called');

        // Case 2: set_fatal();
        $is_call    = false;

        $exception  = new BaseException('test');

        $callback   = function ($actual_exception) use ($exception, &$is_call) {
            $this->assertInstanceOf(BaseException::class, $actual_exception);
            $this->assertTrue(
                $actual_exception === $exception,
                '$actual_exception not equal $exception'
            );
            $is_call = true;
        };

        Registry::setFatalHandler(new ExceptionHandler($callback));

        // call this
        $exception->markAsFatal();

        $this->assertTrue($is_call, '$callback isn\'t called');
    }

    public function testSaveExceptionHandler(): void
    {
        $is_call    = false;

        $exception  = new LoggableException('test');

        $callback   = function (array $exceptions, callable $reset, $logger_opt, $debug_opt) use ($exception, &$is_call) {
            $this->assertIsArray($exceptions, '$exceptions is not array');
            $this->assertTrue(
                $exceptions[0] === $exception,
                '$exceptions[0] not equal $exception'
            );
            $is_call = true;
        };

        Registry::setSaveHandler(new SaveHandler($callback));

        Registry::saveExceptionLog();

        $this->assertTrue($is_call, '$callback isn\'t called');
    }
}
