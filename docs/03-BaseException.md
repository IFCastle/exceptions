# BaseException

## Конструктор

Конструктор `BaseException` имеет три режима работы:

1. Стандартный (как это определено в `\Exception`).
2. Режим структурированных данных.
3. Режим контейнера.

Наследуемые исключения могут так же прозрачно поддерживать эти режимы, а могут перекрывать их своим конструктором.

Например, класс `UnexpectedValue`, может вести себя как `BaseException`, 
если параметр `$name` будет массивом.

```php
/**
 * The variable has an unexpected value!
 */
class UnexpectedValue extends LoggableException
{
    protected string $template      = 'Unexpected value {value} occurred in the variable {name}';
    
    /**
     * The variable has an unexpected value!
     *
     * @param string|array $name                        Variable name
     *                                                  or list of parameters for exception
     * @param mixed        $value                       Value
     * @param string|class-string|null  $rules          Rules description
     */
    public function __construct(array|string $name, mixed $value = null, string|null $rules = null)
    {
        if (!\is_scalar($name)) {
            parent::__construct($name);
            return;
        }

        parent::__construct([
            'name'        => $name,
            'value'       => $this->toString($value),
            'message'     => $rules,
            'type'        => $this->typeInfo($value),
        ]);
    }
}
```

## Шаблоны сообщений

Каждое исключение может иметь свой уникальный шаблон сообщения, которые можно определить в свойстве `template`:

```php
class UnexpectedValueType   extends LoggableException
{
    protected $template         = 'Unexpected type occurred for the value {name} and type {type}. Expected {expected}';
```

Шаблон сообщения так же может быть передан в контексте исключения с помощью специального ключа `template`:

```php
    $exception = new UnexpectedValueType
    ([
        'template'  => 'Custom template {name} {type} {expected}',
        'name'      => 'test',
        'type'      => 'string',
        'expected'  => 'integer'
    ]);
```

Формат строки шаблона соответствует правилам [PSR-3](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md). 

Если исключение определяет шаблон, тогда конструктор `BaseException` работает следующим образом:

1. *Placeholders* шаблона заменяются данными из контекста, и передаются в конструктор `\Exception`. 
Таким образом, метод `getMessage()` вернёт полный текст ошибки.
2. Если в конструктор `BaseException` передано свойство `message`, 
оно воспринимается как дополнительное сообщение, и присоединятся к результирующему сообщению через точку. Например:

```php

        $exception                  = new BaseException
        ([
            'template'              => 'This is the template',
            'message'               => 'This is a message'
        ]);
        
        echo $exception->getMessage();

// Result:
// This is the template. This is a message

``` 

## Управление журналированием

Класс `BaseException` имеет два флага, которые управляют журналированием:
* `isLoggable` - флаг, указывающий, что исключение должно быть записано в журнал.
* `isFatal`    - флаг, указывающий, что исключение является фатальным.

Каким образом эти флажки будут использоваться, зависит от реализации журналирования, однако общие правила таковы:
1. Если не установлен флаг `isLoggable`, то исключение не будет записано в журнал.
2. Если исключение является фатальным, то оно будет записано в журнал.
3. Если исключение не является фатальным, но установлен флаг `isLoggable`, то оно будет записано в журнал.

Фатальные исключения могут быть обработаны особым образом, но это зависит от реализации.

## Наследование

В большинстве случаев дочерний класс переопределяет только конструктор, так как ему нужно сформировать данные исключения.

Если дочернему классу требуется изменить поведение исключения, он может изменять унаследованные свойства. 
В данном случае - это поведение является нормальным.

Упрощённый алгоритм `BaseException::__construct`:

1. Анализировать входные данные.
2. Вызвать родительский конструктор `\Exception`.
3. Если `BaseException::isLoggable` финализировать исключение.
4. Если `BaseException::isFatal` вызвать обработчик фатальных исключений.

Конструктор может изменять любые свойства после своего вызова. 
Поэтому, если нужно модифицировать свойства класса окончательно, делайте это после вызова базового конструктора.

Изменение свойств флажков (с префиксом `is`) вызывает изменение в поведении базового конструктора.

Например, вот так можно включить журналирование:

```php
    class LoggableException extends BaseException
    {
        /**
         * Флаг логирования.
         * Если флаг равен true - то исключение
         * собирается быть записанным в журнал.
         *
         * @var         boolean
         */
        protected $isLoggable  = true;
    }
```

А вот это исключение является фатальным:

```php
    class MyException extends BaseException
    {
        protected $isFatal  = true;
    }
```

Класс `BaseException` не журналируется и не имеет аспектов. 
Поэтому для наследования удобно иметь дополнительные "базовые исключения":

1. `LoggableException` - для исключений, которые журналируются.
2. `SystemException`   - для исключений с аспектом "системное".
3. `RuntimeException`  - для исключений с аспектом "runtime".
4. `FatalException`, `FatalRuntimeException`, `FatalSystemException` - для фатальных исключений.

(подробнее о морализировании в разделе: [Журналирование][1])

## Рекомендации по формированию данных

Обратите внимание, что конструктор `BaseException` не изменяет данные, которые вы передаёте ему. 
Эту работу обязаны делать дочерние исключения.

Хорошо придерживаться рекомендаций:

1. Не хранить в исключении объекты.
2. При формировании `data` усекать данные.
3. Сохранять только самое важное и необходимое.
4. Использовать в массиве `data` только базовые типы: скаляры и массивы.

### Не хранить в исключении объекты

Исключения могут попадать в журнал, и хранится в памяти намного дольше, чем объекты, переданные в исключение. 
Таким образом, вы будете раздувать приложение, так как сборщик мусора не сможет освободить память. 
Если для Web-скриптов это не актуально, то для фоновых заданий - скорее всего.

### Усечение данных

Свойство `BaseException::data` попадает в журнал. 
Хотя данные, которые попадают в журнал, сохраняют структуру, и могут быть десериализированы заново, 
не стоит использовать большие массивы данных. 
Это не только замедляет процесс обработки журнала, но и создаёт ненужную избыточность. 
Если в самом деле необходимо сохранять большие массивы данных, лучше использовать отладочный режим.

Для усечения данных можно использовать методы:

- `BaseException::getType()`;
- `BaseException::truncate()`.

### Использование в data базовых типов

Это требование имеет с одной стороны тот же смысл, что и "Не хранить объекты в исключении". 
Но главная причина иная. Свойство `data` может участвовать в процессе сериализации исключения. 
А объекты не всегда можно правильно сериализировать/десериалировать. 
Хотя можно воспользовать интерфейсом `Serializable` - это не самая хорошая идея, 
так как целью сериализации могут быть другие форматы, отличные по сути от `Serializable`.

Если вы хотите получить возможность легко сериализировать исключения - пытайтесь строго следовать этому правилу.

## Отладочные данные

Для сохранения отладочных данных, 
`BaseException` предоставляет метод `set_debug_data()`. 
Этот метод имеет атрибут `protected`, а значит предназначен только для внутреннего использования.

Алгоритм `BaseException::setDebugData()`:

1. Проверить, активен ли режим отладки.
2. Если да, перевести данные в строку, и сохранить их.

Пример использования:

```php
    class UnexpectedValue   extends LoggableException
    {
        public function __construct($name, $value = null)
        {
            // Для журнала отладки сохраним полные данные:
            $this->setDebugData(['value' => $value]);

            parent::__construct
            ([
                    'message'     => 'Unexpected value',
                    'name'        => $name,
                    'type'        => self::getValueType($value)
            ]);
        }
    }
```

Используя свойство `isDebug`, вы можете намеренно записать данные, в независимости от того, включён ли режим отладки или нет:

```php
    class UnexpectedValue   extends LoggableException
    {
        public function __construct($name, $value = null)
        {
            // Принудительное включение режима отладки
            $this->isDebug      = true;
            // Для отладчика сохраним полные данные:
            $this->setDebugData(['value' => $value]);

            parent::__construct
            ([
                    'message'     => 'Unexpected value',
                    'name'        => $name,
                    'type'        => self::get_value_type($value)
            ]);            
        }
    }
```

При этом отладочные данные запишутся только для вашего исключения. 
Это позволяет быстро ввести отладочный режим даже на рабочей системе, только в необходимом месте.

Таким же образом, можно и отключить отладочный режим:

```php
    // Все исключения, которые наследуются от этого 
    // получат выключенный отладочный режим
    // (если конечно не переопределят его явно)
    class NoDebugException   extends LoggableException
    {
        protected $isDebug = false;
    }
```

## Сериализация

Кроме основных методов `BaseException` поддерживает сериализацию/десериализацию. 
Это может быть полезно для маршалинга исключений через удалённые сервисы, 
сохранения исключений на диск и прочего, где обычно используется сериализация.

Целевым форматом сериализации является асоциативный массив. 
Массив выбран потому, что его легко преобразовать в любой другой формат: `json`, `xml`, `phpserialize`, etc.

Формат массива:

```php
    [
        'type'      => get_class($exception),
        'source'    => ['source' => '', 'type' => '', 'function' => ''],
        'message'   => $exception->getMessage(),
        'template'	=> $exception->template(),
        'code'      => $exception->getCode(),
        'data'      => $exception->get_data(),
        'container' => 'если это контейнер-исключение'
    ];
```

Исключения контейнеры возвращают сериализацию не самих себя, а исключения `previous`.

За общую сериализацию/десериализацию отвечают  методы:

- `BaseException::toArray()`;
- `BaseException::arrayToErrors()`.

Метод arrayToErrors является защищённым, и предназначен для использования в дочерних классах, только в том случае, 
если исключение может быть восстановлено из сериализованных данных. 
Обычно такие исключения являются DTO объектами, что не является общим случаем.

## Особенности

Следующие методы `BaseException` существуют потому, что стандартные методы `PHP` `\Exception` объявлены как `final`, 
но поведение их не соответствует общей парадигме `BaseException`. 

### Определение источника исключения

Для определения источника исключения используется специальный метод `BaseException::get_source()`. Он возвращает ассоциативный массив вида:

```php
    [
        'source'    => 'класс или файл:строка, где возникло исключение',
        'type'      => 'тип вызова',
        'function'  => 'имя функции или метода, где возникло исключение'
    ];
```

Метод `BaseException::getSource()` используется при журналировании вместо метода 
`BaseException::getFile()`, 
потому что определение источника по имени класса является более естественным методом относительно устройства языка. 
После введения `namespace`  и `autoload` реальная структура файлов больше не имеет большого значения, 
а информация об `namespace` сохраняется и тогда, когда весь код объединяется в один файл.

Обратите внимание, что порядок ключей в массиве `source` имеет значение, и он создан таким образом, что если выполнить слияние массива в строку, то вы получите строковое указание источника:

```php
    
    namespace Test;
        
    class ZClass
    {
        function zfun()
        {
            throw new BaseException('...');
        }
    }

    try
    {
        $Test = new ZClass();
        $Test->zfun(); 
    }
    catch(BaseException $e)
    {
        // out: Test\ZClass->zfun
        echo implode('', $exception->getSource());        
    }
```

Для вычисления источника классов `PHP` `\Exception` используйте метод `HelperTrait::getSourceFor()`.

### Определение вложенного исключения

`BaseException` создаёт контейнеры для любых объектов, которые поддерживают интерфейс `BaseExceptionInterface`. 
Этот приём позволяет оборачивать в исключения другие объекты, которые имеют схожее поведение, но не являются `PHP` исключениями.

Однако `\Exception::$previous` может быть только дочерним объектом от `\Exception`. Чтобы обойти это органичение, `BaseException` помещает объект `BaseExceptionI` в свойство `data` (в контейнере это свойство не используется для данных).

Для доступа к вложенному объекту `BaseExceptionI` следует использовать метод `BaseExceptionI::get_previous()`, который всегда вернёт правильный объект: 

- `\Exception`;
- либо `BaseExceptionI`;
- либо `null`, если объекта нет.

[1]: 04-Logging.md "Журналирование"
