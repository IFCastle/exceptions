# Paradigm

## Исключения и логирование

Создание классов исключений тесно связаны с методикой логирования.

Исключения создаются с двумя целями:

1. Передать информацию о произошедшей ошибке для кода.
2. Предоставить достаточную информацию для логирования.

Для решения первой задачи, используются классы и интерфейсы, позволяя коду по типу исключения определить, что произошло.
Для решения второй задачи, используются метаданные исключения, которые позволяют логировать исключения с дополнительной информацией.

Поэтому, создавая новый класс исключения, необходимо учитывать, 
что он должен содержать метаданные, которые будут использоваться для логирования.

```php

final class UserNotAllowed extends \IfCastle\Exceptions\BaseException
{
    protected string $template      = 'User {user} from {ip} is not allowed';
    protected array $tags           = ['user', 'auth'];

    public function __construct(string $user, string $ip)
    {
        parent::__construct([
            'user' => $user,
            'ip'   => $ip
        ]);
    }

```

В данном примере, класс `UserNotAllowed` содержит шаблон сообщения и теги, которые будут использоваться для логирования.
Когда это исключение попадёт в логгер, он сможет использовать шаблон сообщения и теги для формирования сообщения об ошибке.

```php
    $exception = new UserNotAllowed('admin', '127.0.0.1');
    $logger->error($exception);
```

Если в качестве системы логирования вы используете OpenTelemetry, 
в таком случае метаданные исключения будут использоваться для формирования атрибутов,
которые попадут в трейсер вместе с тегами и шаблоном сообщения.

## Исключения и теги

Теги позволяют сгруппировать исключения произвольным образом.

Создавая класс исключения можно определить теги, которые позже попадут в логгер.

```php
final class MyException extends \IfCastle\Exceptions\BaseException
{
    protected array $tags = ['system', 'service'];
}
```

Вы так же можете передать теги в конструкторе исключения.

```php
    $exception = new MyException(['tags' => ['custom', 'tag']]);
    $logger->error($exception);
```

Теги, добавленные в конструкторе, будут объединены с тегами, определёнными в классе исключения.

## Исключения и аспекты

Иногда нужно разделить разные исключения по особым типам обработки. 
Например, некоторые исключения могут быть показаны пользователю, в то время, когда другие -- нет.

`BaseException` предлагает для этого специальный интерфейс: `ClientAvailableInterface`, 
который указывает, что исключение может быть показано пользователю.

Интерфейс так же содержит дополнительные методы:
* `getClientMessage`
* `clientSerialize`

Которые позволяют получить сообщение для пользователя и сериализовать исключение для клиента особым образом, 
в то время как в журнал будут записаны метаданные исключения.

Кроме аспекта `ClientAvailableInterface`, `BaseException` так же предлагает такие аспекты:
* `SystemExceptionInterface` - исключение, которое произошло из-за ошибки в системе, например диск переполнен.
* `RuntimeExceptionInterface` - исключение, которое случилось во время работы программы, но не является ошибкой программиста.

Все другие исключения считаются ошибками программиста и не должны быть показаны пользователю.